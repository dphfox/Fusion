<nav class="fusiondoc-api-breadcrumbs">
	<a href="../..">Fusion</a>
	<a href="..">State</a>
</nav>

<h1 class="fusiondoc-api-header" markdown>
	<span class="fusiondoc-api-icon" markdown>:octicons-package-24:</span>
	<span class="fusiondoc-api-name">ForPairs</span>
	<span class="fusiondoc-api-pills">
		<span class="fusiondoc-api-pill-type">state object</span>
		<span class="fusiondoc-api-pill-since">since v0.2</span>
	</span>
</h1>

Processes a table from another state object by transforming its keys and values.

```Lua
(
	input: CanBeState<{[KI]: VI}>,
	pairProcessor: (Use, KI, VI) -> (KO, VO, M),
	pairDestructor: ((KO, VO, M) -> ())?
) -> ForPairs<KI, VI, KO, VO, M>
```

-----

## Parameters

- `input: CanBeState<{[KI]: VI}>` - the table to be processed, either as a state
object or a constant value
- `pairProcessor: (Use, KI, VI) -> (KO, VO, M)` - transforms input key-value
pairs into new key-value pairs, optionally providing metadata for the destructor
alone
- `pairDestructor: ((KO, VO, M) -> ())?` - disposes of values generated by
`pairProcessor` when they are no longer in use

-----

## Example Usage

```Lua
local data = Value({
	one = 1,
	two = 2,
	three = 3,
	four = 4
})

local transformed = ForPairs(data, function(use, key, value)
	local newKey = value
	local newValue = string.upper(key)
	return newKey, newValue
end)

print(peek(transformed)) --> {[1] = "ONE", [2] = "TWO" ... }
```

-----

## Dependency Management

By default, ForPairs runs the processor function once per key/value pair in the
input, then caches the result indefinitely. To specify the calculation should
re-run for the key/value pair when a state object changes value, the objects can
be passed to the [use callback](./use.md) passed to the processor function for
that key/value pair. The use callback will unwrap the value as normal, but any
state objects will become dependencies of that key/value pair.

-----

## Destructors

The `pairDestructor` callback, if provided, is called when this object swaps
out an old key-value pair for a newly-generated one. It is called with the old
pair as the first and second parameters, and - if provided - an extra value
returned from `pairProcessor` as a customisable third parameter.

Destructors are required when working with data types that require destruction,
such as instances. Otherwise, they are optional, so not all calculations have to
specify destruction behaviour.

Fusion guarantees that values passed to destructors by default will never be
used again by the library, so it is safe to finalise them. This does not apply
to the customisable third parameter, which the user is responsible for handling
properly.

-----

## Optimisations

ForPairs is the least restrictive of the For objects, allowing full access to
the key-value pairs being processed. This means that very little optimisation is
applied - values are always locked to the specific key they were generated for,
and any change in the input's key or value will prompt a recalculation.

For other optimisations, consider using [ForValues](../forvalues) or
[ForKeys](../forkeys), which impose stricter restrictions to allow for less
frequent updates and greater reuse.