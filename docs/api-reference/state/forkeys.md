<nav class="fusiondoc-api-breadcrumbs">
	<a href="../..">Fusion</a>
	<a href="..">State</a>
</nav>

<h1 class="fusiondoc-api-header" markdown>
	<span class="fusiondoc-api-icon" markdown>:octicons-package-24:</span>
	<span class="fusiondoc-api-name">ForKeys</span>
	<span class="fusiondoc-api-pills">
		<span class="fusiondoc-api-pill-type">state object</span>
		<span class="fusiondoc-api-pill-since">since v0.2</span>
	</span>
</h1>

Processes a table from another state object by transforming its keys only.

```Lua
(
	input: CanBeState<{[KI]: V}>,
	keyProcessor: (Use, KI) -> (KO, M),
	keyDestructor: ((KO, M) -> ())?
) -> ForKeys<KI, KO, V, M>
```

-----

## Parameters

- `input: CanBeState<{[KI]: V}>` - the table to be processed, either as a state
object or a constant value
- `keyProcessor: (Use, KI) -> (KO, M)` - transforms input keys into new
keys, optionally providing metadata for the destructor alone
- `keyDestructor: ((KO, M) -> ())?` - disposes of values generated by
`keyProcessor` when they are no longer in use

-----

## Example Usage

```Lua
local data = Value({
	one = 1,
	two = 2,
	three = 3,
	four = 4
})

local transformed = ForKeys(data, function(use, key)
	local newKey = string.upper(key)
	return newKey
end)

print(peek(transformed)) --> {ONE = 1, TWO = 2 ... }
```

-----

## Dependency Management

By default, ForKeys runs the processor function once per key in the input, then
caches the result indefinitely. To specify the calculation should re-run for the
key when a state object changes value, the objects can be passed to the
[use callback](./use.md) passed to the processor function for that key. The use
callback will unwrap the value as normal, but any state objects will become
dependencies of that key.

-----

## Destructors

The `keyDestructor` callback, if provided, is called when this object swaps out
an old key for a newly-generated one. It is called with the old key as the first
parameter, and - if provided - an extra value returned from `keyProcessor` as a
customisable second parameter.

Destructors are required when working with data types that require destruction,
such as instances. Otherwise, they are optional, so not all calculations have to
specify destruction behaviour.

Fusion guarantees that values passed to destructors by default will never be
used again by the library, so it is safe to finalise them. This does not apply
to the customisable second parameter, which the user is responsible for handling
properly.

-----

## Optimisations

ForKeys does not allow access to the values of the input table. This guarantees
that all generated keys are completely independent of any values. This means
keys only need to be calculated when they're added to the input table - all
other changes are simply forwarded to the output table. Since keys are also
unique, all calculations are unique, so caching and reuse are not required.