<nav class="fusiondoc-api-breadcrumbs">
	<a href="../..">Fusion</a>
	<a href="..">State</a>
</nav>

<h1 class="fusiondoc-api-header" markdown>
	<span class="fusiondoc-api-icon" markdown>:octicons-package-24:</span>
	<span class="fusiondoc-api-name">Computed</span>
	<span class="fusiondoc-api-pills">
		<span class="fusiondoc-api-pill-type">state object</span>
		<span class="fusiondoc-api-pill-since">since v0.1</span>
	</span>
</h1>

Calculates a single value based on the returned values from other state objects.

```Lua
(
	processor: (Use) -> (T, M),
	destructor: ((T, M) -> ())?
) -> Computed<T, M>
```

-----

## Parameters

- `processor: (Use) -> (T, M)` - computes and returns values to be returned from
the computed object, optionally returning extra values for the destructor alone

- `destructor: ((T, M) -> ())?` - disposes of values generated by `processor`
when they are no longer in use

-----

## Example Usage

```Lua
local numCoins = Value(50)

local doubleCoins = Computed(function(use)
	return use(numCoins) * 2
end)

print(peek(doubleCoins)) --> 100

numCoins:set(2)
print(peek(doubleCoins)) --> 4
```

-----

## Dependency Management

By default, computed objects run their processor function once during
construction, then cache the result indefinitely. To specify the calculation
should re-run when a state object changes value, the objects can be passed
to the [use callback](./use.md) passed to the processor function. The use
callback will unwrap the value as normal, but any state objects will become
dependencies of the computed object.

-----

## Destructors

The `destructor` callback, if provided, is called when the computed object swaps
out an old value for a newly-generated one. It is called with the old value as
the first parameter, and - if provided - an extra value returned from `processor`
as a customisable second parameter.

Destructors are required when working with data types that require destruction,
such as instances. Otherwise, they are optional, so not all calculations have to
specify destruction behaviour.

Fusion guarantees that values passed to destructors by default will never be
used again by the library, so it is safe to finalise them. This does not apply
to the customisable second parameter, which the user is responsible for handling
properly.